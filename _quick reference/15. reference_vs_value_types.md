# Reference vs Value Types in C

In C, the distinction between "reference types" and "value types" isn't part of the standard terminology, but the underlying concepts exist through **value semantics** and **pointer semantics**.

## Value Semantics (Most Types)

All basic types in C follow value semantics by default:
- `int`, `float`, `double`, `char`
- `struct` and `union` types
- Arrays (with caveats)

When you assign or pass these to functions, you work with **copies** of the data:

```c
int a = 10;
int b = a;    // b gets a copy of a's value
b = 20;       // only b changes, a remains 10

void modify(int x) {
    x = 100;  // modifies local copy only
}

int main() {
    int num = 5;
    modify(num);  // num still equals 5
}
```

## Pointer Semantics (Reference-like Behavior)

Pointers allow you to work with data indirectly through addresses:

```c
int a = 10;
int *ptr = &a;  // ptr holds the address of a
*ptr = 20;      // modifies a through the pointer

void modify(int *x) {
    *x = 100;   // modifies the original value
}

int main() {
    int num = 5;
    modify(&num);  // num now equals 100
}
```

## Arrays: Special Case

Arrays decay to pointers when passed to functions, creating reference-like behavior:

```c
void modify_array(int arr[], int size) {
    arr[0] = 100;  // modifies original array
}

int main() {
    int numbers[5] = {1, 2, 3, 4, 5};
    modify_array(numbers, 5);  // numbers[0] is now 100
}
```

## Structs

Structs are value types but can be passed by pointer for efficiency:

```c
struct Point {
    int x, y;
};

void move_value(struct Point p) {
    p.x += 10;  // modifies copy only
}

void move_ref(struct Point *p) {
    p->x += 10;  // modifies original
}
```

**Key Distinction:** C requires explicit use of pointers to achieve reference semantics, unlike languages with built-in reference types.
